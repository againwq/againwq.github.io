[{"content":"一、GoldenDict基本介绍 GoldenDict是一款开源的词典软件,它具有高度的定制性,可以自定义软件界面,它支持导入词典数据、调用外部网站和自定义程序等功能,对于需要 在学习中阅读英文文献时非常方便使用。在Debian12中可以直接通过apt命令下载该软件\nsudo apt update sudo apt install goldendict 下载完毕后,软件界面如下：\n在上面工具栏的编辑 -\u0026gt; 首选项 -\u0026gt; 界面可以设置界面语言,并且可以配置内置的一些主题风格,本文不讨论如何自定义界面风格。在编辑 -\u0026gt; 首选项 -\u0026gt; 词典可以配置词典数据来源。Golden支持多种词典来源,包括本地的词典数据、远程词典服务器、调用搜索引擎和调用脚本程序等。本文会给出一些在网络上搜集的本地词典资源（感谢这些资源的提供者）,并给出一个调用百度官方api进行翻译的python脚本。\n二、词典资源配置 1.本地词典资源 打开编辑 -\u0026gt; 首选项 -\u0026gt; 词典 -\u0026gt; 词典来源 -\u0026gt; 文件,这里可以配置词典文件的路径,如果是文件夹路径需要勾上递归搜索,然后点击应用,这样GoldenDict会扫描所有指定的词典文件,并为其生成索引。如果词典数量比较多这个过程会比较漫长,这取决于你的电脑的性能。索引生成完毕后这些词典就可以使用了,索引文件会存储在本地磁盘中,下一次打开不需要重新生成了。我自己用的词典资源： 词典资源 提取码: bp47。 示例效果如图所示：\n2. 调用百度翻译接口 拥有这些本地词典后,GoldenDict会帮助你从这些本地词典搜索你要查询的单词或者词语,只要你的词典中有对应的记录即可。但是GoldenDict并不支持句子翻译,即它不会把句子拆成一组单词分别去查询,除非你的词典中有这样一条句子的翻译记录。因此我考虑将百度翻译接入到GoldenDict中这样方便进行一些简短的句子翻译。 首先需要在百度翻译api注册账户,选择通用翻译服务,进行认证后高级版通用翻译服务每个月会有一定量的免费额度。然后在管理控制台获取你的APP ID和密钥,替换下面代码中的APP ID和密钥,并配置日志文件路径：\nimport requests import random import re from hashlib import md5 import sys import time # 设置你自己的appid和appkey appid = \u0026#39;xxxxxxxxxxxxxxxxxx\u0026#39; appkey = \u0026#39;xxxxxxxxxxxxxxxxxx\u0026#39; EN_LIMIT = 800 # 每800个英文字符添加一个换行符 ZH_LIMIT = 300 # 每300个汉字添加一个换行符 EN_MIN_NUM = 8 ZH_MIN_NUM = 5 def hasZhChar(text): pattern = re.compile(r\u0026#39;[\\u4e00-\\u9fa5]\u0026#39;) match = pattern.search(text) return bool(match) def make_md5(s, encoding=\u0026#39;utf-8\u0026#39;): return md5(s.encode(encoding)).hexdigest() def full2half(s): #全角转成半角 n = \u0026#39;\u0026#39; for char in s: num = ord(char) if num == 0x3000: num = 32 elif 0xFF01 \u0026lt;=num \u0026lt;= 0xFF5E: num -= 0xFEE0 num = chr(num) n += num return n def split_data(sentences, limit): data = \u0026#34;\u0026#34; if len(sentences) \u0026lt; EN_LIMIT: data = sentences else: positon = EN_LIMIT while sentences[positon] != \u0026#39; \u0026#39;: positon -= 1 data += sentences[:positon] + \u0026#39;\\n\u0026#39; data += split_data(sentences[positon + 1:], limit) return data from_lang = \u0026#39;en\u0026#39; to_lang = \u0026#39;zh\u0026#39; endpoint = \u0026#39;http://api.fanyi.baidu.com\u0026#39; path = \u0026#39;/api/trans/vip/translate\u0026#39; url = endpoint + path headers = {\u0026#39;Content-Type\u0026#39;: \u0026#39;application/x-www-form-urlencoded\u0026#39;} today = time.strftime(\u0026#34;%Y-%m-%d\u0026#34;, time.localtime()) if __name__ == \u0026#39;__main__\u0026#39;: sentences = full2half(sys.argv[1].replace(\u0026#39;\\n\u0026#39;, \u0026#39; \u0026#39;)) salt = random.randint(32768, 65536) if hasZhChar(sentences): from_lang = \u0026#39;zh\u0026#39; to_lang = \u0026#39;en\u0026#39; if len(sentences) \u0026lt; ZH_MIN_NUM: print(f\u0026#34;汉字数量小于{ZH_MIN_NUM}个,不翻译\u0026#34;) sys.exit(0) else: from_lang = \u0026#39;en\u0026#39; to_lang = \u0026#39;zh\u0026#39; if len(sentences.split(\u0026#39; \u0026#39;)) \u0026lt; EN_MIN_NUM: print(f\u0026#34;单词数量小于{EN_MIN_NUM}个,不翻译\u0026#34;) sys.exit(0) # Build request query = split_data(sentences, EN_LIMIT) if from_lang == \u0026#39;en\u0026#39; else split_data(sentences, ZH_LIMIT) sign = make_md5(appid + query + str(salt) + appkey) payload = {\u0026#39;appid\u0026#39;: appid, \u0026#39;q\u0026#39;: query, \u0026#39;from\u0026#39;: from_lang, \u0026#39;to\u0026#39;: to_lang, \u0026#39;salt\u0026#39;: salt, \u0026#39;sign\u0026#39;: sign} # Send request r = requests.post(url, params=payload, headers=headers) result = r.json() if \u0026#34;error_code\u0026#34; in result: print(\u0026#34;Error: \u0026#34;, result) print(\u0026#34;length: \u0026#34;, len(query)) sys.exit(0) res = \u0026#34;\u0026#34; for item in result[\u0026#34;trans_result\u0026#34;]: res += item[\u0026#34;dst\u0026#34;] + \u0026#39; \u0026#39; print(res) 然后需要在GoldenDict中配置,打开编辑 -\u0026gt; 词典 -\u0026gt; 词典来源 -\u0026gt; 程序,添加下面一条记录：\n已启用 类型 名称 命令行 ✔ 文本 Baidu python 你的python脚本的绝对路径 %GDWORD% 为了方便使用GoldenDict,而不是每次都打开软件然后复制进去,我们需要启用编辑 -\u0026gt; 首选项 -\u0026gt; 热键,然后勾上使用Ctrl + C + C获取剪切板的热键,这样GoldenDict只要在后台启动,我们就可以使用热键调出翻译窗口了,效果如图所示：\n上面的代码没有像图片中一样提供实时获取额度的功能,这个功能和真实的额度有一些小偏差,而且存在一些小bug,因此就不放上来了。读者可以自行修改代码实现自定义功能。 当然,百度翻译api网站的控制台可以查看每月的额度,只是不是实时的。\n","permalink":"https://againwq.github.io/posts/debian%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8/goldendict/","summary":"一、GoldenDict基本介绍 GoldenDict是一款开源的词典软件,它具有高度的定制性,可以自定义软件界面,它支持导入词典数据、调用外部网站和自定义程序等功能,对于需要 在学习中阅读英文文献时非常方便使用。在Debian12中可以直接通过apt命令下载该软件\nsudo apt update sudo apt install goldendict 下载完毕后,软件界面如下：\n在上面工具栏的编辑 -\u0026gt; 首选项 -\u0026gt; 界面可以设置界面语言,并且可以配置内置的一些主题风格,本文不讨论如何自定义界面风格。在编辑 -\u0026gt; 首选项 -\u0026gt; 词典可以配置词典数据来源。Golden支持多种词典来源,包括本地的词典数据、远程词典服务器、调用搜索引擎和调用脚本程序等。本文会给出一些在网络上搜集的本地词典资源（感谢这些资源的提供者）,并给出一个调用百度官方api进行翻译的python脚本。\n二、词典资源配置 1.本地词典资源 打开编辑 -\u0026gt; 首选项 -\u0026gt; 词典 -\u0026gt; 词典来源 -\u0026gt; 文件,这里可以配置词典文件的路径,如果是文件夹路径需要勾上递归搜索,然后点击应用,这样GoldenDict会扫描所有指定的词典文件,并为其生成索引。如果词典数量比较多这个过程会比较漫长,这取决于你的电脑的性能。索引生成完毕后这些词典就可以使用了,索引文件会存储在本地磁盘中,下一次打开不需要重新生成了。我自己用的词典资源： 词典资源 提取码: bp47。 示例效果如图所示：\n2. 调用百度翻译接口 拥有这些本地词典后,GoldenDict会帮助你从这些本地词典搜索你要查询的单词或者词语,只要你的词典中有对应的记录即可。但是GoldenDict并不支持句子翻译,即它不会把句子拆成一组单词分别去查询,除非你的词典中有这样一条句子的翻译记录。因此我考虑将百度翻译接入到GoldenDict中这样方便进行一些简短的句子翻译。 首先需要在百度翻译api注册账户,选择通用翻译服务,进行认证后高级版通用翻译服务每个月会有一定量的免费额度。然后在管理控制台获取你的APP ID和密钥,替换下面代码中的APP ID和密钥,并配置日志文件路径：\nimport requests import random import re from hashlib import md5 import sys import time # 设置你自己的appid和appkey appid = \u0026#39;xxxxxxxxxxxxxxxxxx\u0026#39; appkey = \u0026#39;xxxxxxxxxxxxxxxxxx\u0026#39; EN_LIMIT = 800 # 每800个英文字符添加一个换行符 ZH_LIMIT = 300 # 每300个汉字添加一个换行符 EN_MIN_NUM = 8 ZH_MIN_NUM = 5 def hasZhChar(text): pattern = re.","title":"Debian12中GoldenDict词典软件的使用"},{"content":"一、sinx泰勒展开的C实现 1.sinx泰勒展开公式 sinx的泰勒展开如下：\n$$ sinx = x - \\frac{x^3}{3!} + \\frac{x^5}{5!} - \\frac{x^7}{7!} + \u0026hellip; + \\frac{(-1)^n}{(2n + 1)!}x^{2n+1} $$\n其中n从0开始计算，我采用的公式形态上是x=0处的泰勒展开。实际上我们可以把x写成$x = x + x_0$来实现$x=x_0$处的展开\n2.C实现sinx泰勒展开 我们通过控制精度来控制展开项数，并且我们只考虑$0-2\\pi$的范围，归一化处理我们之后再详细考虑，通过泰勒展开公式我们的C程序如下，\n#include \u0026lt;math.h\u0026gt; #define degree 1e-2 float fun_sin(float x) { float res, term; int i; int factor; // 阶乘 term = x; // 每一项的结果 factor = 1; res = term; for (i = 1; fabs(term) \u0026gt; degree; i++) { factor *= (2 * i) * (2 * i + 1); term = pow(-1, i) * pow(x, 2 * i + 1) / factor; res += term; } return res; } 上面的代码基本是严格按照公式计算的，可惜的是它并不能正常工作，这涉及到计算阶乘时整数溢出的问题。当输入比较小，比如0.2，那么大概在第二项就达到了我们设定的精度0.01了，此时factor为6，但是如果输入为6.23左右时，我们要计算10项以上才能达到我们设定的精度，第10项需要计算21的阶乘，即便使用64位无符号整型存储也不够，因此我们需要对其进行一定的优化\n二、sinx泰勒展开优化 1.通过固定计算的阶数来保证不溢出 很容易想到的一点就是我们可以通过固定展开的项数来保证计算过程不会溢出，比如我们固定每次展开项数为7，C程序如下\n#include \u0026lt;math.h\u0026gt; #define TIMES 7 float fun_sin(float x) { float res, term; int i; unsigned long factor; factor = 1; res = x; for (i = 1; i \u0026lt; TIMES; i++) { factor *= (2 * i) * (2 * i + 1); res += pow(-1, i) * pow(x, 2 * i + 1) / factor; } return res; } 经测试，该程序在$0-2\\pi$内不会出现精度溢出的问题\n2.从公式出发改变实现方法 观察sinx的泰勒展开我们可以得到如下规律：\n记第i项展开式为 $a_i = \\frac{(-1)^i}{(2i + 1)!}x^{2i+1}$ 则有 $a_i = a_{i-1} \\cdot \\frac{-x^2}{(2i)\\cdot(2i+1)}$ 我们可以看出相邻两项相差一个乘积因子$\\frac{-x^2}{(2i)\\cdot(2i+1)}$，而且这个因子中不会产生太大的数据导致数据溢出。这样我们可以保留通过精度控制展开项数的方法，而且不会产生数据溢出。实现的C程序如下：\n#include \u0026lt;math.h\u0026gt; #define pi 3.14159265 #define degree 1e-2\t// ̩精度设置 const float factor_diff_mem[10] = // 乘积因子的分母部分 { 1.0, 1.0 / 6, 1.0 / 20, 1.0 / 42, 1.0 / 72, 1.0 / 110, 1.0 / 156, 1.0 / 210, 1.0 / 272, 1.0 / 342 }; float fun_sin(float x) { float sum; float diff; int i; float term; sum = x; term = x; // 展开的每一项 diff = -1 * x * x; //乘积因子的分子部分 for (i = 1; fabs(term) \u0026gt; degree; i++) { term *= diff * factor_diff_mem[i]; sum += term; } return sum; } 这里我们也做了一些优化，我们不再在for循环中去计算因子的分母部分，而是在编译阶段直接计算出，程序运行时直接查表即可，这也是经典的空间换时间的优化方式。可以看到现在这个程序已经没有指数和阶乘这种费时又可能导致溢出的计算了\n三、三种方法时间比较 1.测试环境和代码 接下来我们将这两种方法和C标准库下的sinx进行时间上的比较，我采用的平台是x86_64，Debian 12系统，gcc12.2，测试代码如下：\nint get_us_time(){ struct timeval tv; gettimeofday(\u0026amp;tv, NULL); return tv.tv_usec; } int sinx_time_test(float (*fun_sin)(float), float *data, int n, int count) { int start, end; float x; int i, j; start = get_us_time(); for (j = 0; j \u0026lt; count; j++) // 周期数量 { for (i = 0; i \u0026lt;= n; i++) { x = 2 * pi * i / n; // 0-2pi取n个点 data[i] = fun_sin(x); // printf(\u0026#34;%f\\n\u0026#34;, data[i]); } } end = get_us_time(); return end - start; } 这里采用两层循环是为了更方便看到差距以外，还要保证一个周期内不要取太多点，导致输入的x精度过高，这里我们不对精度做太高要求,\n2.程序运行时间对比 三种方法程序运行时间如下：\nC standard Fixed degree Fixed items 184 us 266 us 1701 us 多次运行数值上的结果可能不一样，但是三者的关系基本不变，标准库的sinx最快，其次是我们优化后的固定精度的实现，最后是固定周期的实现。我们可以看到优化后的固定精度的实现和C标准库执行时间差不多，只有几十us的差距，但是固定周期的实现方法运行的时间却是其他两种方法的10倍，可见其效率之低。\n3.程序运行精度对比 我们借助gnuplot去绘制这三种方法的sinx曲线去大概对比精度，如图所示： 可以看到，当x逐渐变大时，固定周期的方法的精度已经出现非常明显的误差了，而我们优化后的固定精度的方法几乎是与标准库的实现完全重叠，甚至我们可以尝试继续调小精度来提升程序运行速度\n四、输入归一化处理 前面我们已经实现了速度接近标准库实现的泰勒展开，但是范围被限定在$(-2\\pi, 2\\pi)$之间，其实我们也可以输入超过这个范围的数据，但是随着输入的绝对值的变大，为了保证相同的精度，泰勒展开项数会逐渐增多，程序运行速度会越来越慢，最后很有有可能导致精度再次溢出。我们不希望不同的输入对程序的运行状态有太大的影响。因此，我们需要对输入进行归一化处理\n1.归一化操作 归一化操作其实很简单，借助sinx的周期性，在本程序中归一化操作如下\nconst float T = 2 * pi; // sinx周期为2pi float fun_sin(float x){ ... int n = (int)(x / T); // 计算周期数量 x -= n * T; // sin(x) = sinx(x - 2n*pi) ... } 2.对除法的优化 在某些平台上，比如DSP芯片中，我们不希望程序中出现除法操作，因为除法是一个非常耗时的操作。在很多DSP芯片中加法和乘法是基本计算操作，cpu只需要一个指令就能完成，但是除法是非常耗时的，所以我们可以尝试改写一下，将其变成乘法的形式\nconst float T = 2 * pi const float f = 1 / T // 编译阶段执行 float fun_sin(float x){ ... x -= T * (int)(x * f) ... } 我们把涉及到除法的部分放到编译阶段执行，这样可以优化在某些不支持快速计算除法的平台上的运行速度\n3.对浮点数截断的操作 这个优化也是在DSP芯片的场景中，我们使用int类型强制转换来对浮点数进行截断操作，这句话看起来很简单，实际上是一个非常复杂的操作，因为浮点数的存储方式不像整型数据那样01排列然后根据二进制计算即可，浮点数有其自己的存储方式。你可以很容易通过整型数据的二进制去计算10进制，但是浮点数的二进制却不是那么容易计算。IEEE754标准就定义了浮点数在二进制中的存储格式，这里不做过多介绍。 总之知道存储格式后我们可以通过位运算去进行浮点数截断的操作，我之前在CCS V5.5仿真TMS320VC5509A芯片的平台上测试过，这个方法确实可以提升程序运行速度，甚至比库函数还快，但是在x86平台上几乎没有多少提升。（代码是参考网上一篇文章的，但是我忘记链接了\u0026hellip;）\nunion FloatBit { float f; int f_b; } ret, bias; int Float2Int(float f) // 快速转换浮点数为整数 { ret.f = f; bias.f_b = (23l + 127l) \u0026lt;\u0026lt; 23; if (f \u0026lt; 0.0f) { bias.f_b = ((23l + 127l) \u0026lt;\u0026lt; 23) + (1l \u0026lt;\u0026lt; 22); } ret.f += bias.f; ret.f_b -= bias.f_b; return ret.f_b; } 需要注意你的平台上int位数应该和float一样都是32位，如果int是16位应该换成long或者其他32位的整型类型。\n五、最终程序实现 最终我们优化完的程序如下：\n#include \u0026lt;math.h\u0026gt; #define pi 3.14159265 #define degree 1e-2\t// ̩精度设置 const float factor_diff_mem[10] = // 泰勒展开因子 { 1.0, 1.0 / 6, 1.0 / 20, 1.0 / 42, 1.0 / 72, 1.0 / 110, 1.0 / 156, 1.0 / 210, 1.0 / 272, 1.0 / 342}; const float T = 2 * pi; const float f = 1 / (2 * pi); union FloatBit { float f; int f_b; } ret, bias; int Float2Int(float f) // 快速转换浮点数为整数 { ret.f = f; bias.f_b = (23l + 127l) \u0026lt;\u0026lt; 23; if (f \u0026lt; 0.0f) { bias.f_b = ((23l + 127l) \u0026lt;\u0026lt; 23) + (1l \u0026lt;\u0026lt; 22); } ret.f += bias.f; ret.f_b -= bias.f_b; return ret.f_b; } float fun_sin(float x) { float sum; float diff; int i; float term; x -= T * Float2Int(x * f); sum = x; term = x; diff = -1 * x * x; for (i = 1; fabs(term) \u0026gt; degree; i++) { term *= diff * factor_diff_mem[i]; sum += term; } return sum; } 我们尝试将输入$x$改成$x+b,b=100i, -100 \u0026lt; i \u0026lt; 100$,去将这个程序与C标准库程序对比，如图所示：\n可以看到，两种方法在运行时间和稳定性上差距很小，我们的程序达到了我们预期的性能了\n","permalink":"https://againwq.github.io/posts/c%E8%AF%AD%E8%A8%80/c%E5%AE%9E%E7%8E%B0sinx%E5%B9%B6%E4%BC%98%E5%8C%96/","summary":"一、sinx泰勒展开的C实现 1.sinx泰勒展开公式 sinx的泰勒展开如下：\n$$ sinx = x - \\frac{x^3}{3!} + \\frac{x^5}{5!} - \\frac{x^7}{7!} + \u0026hellip; + \\frac{(-1)^n}{(2n + 1)!}x^{2n+1} $$\n其中n从0开始计算，我采用的公式形态上是x=0处的泰勒展开。实际上我们可以把x写成$x = x + x_0$来实现$x=x_0$处的展开\n2.C实现sinx泰勒展开 我们通过控制精度来控制展开项数，并且我们只考虑$0-2\\pi$的范围，归一化处理我们之后再详细考虑，通过泰勒展开公式我们的C程序如下，\n#include \u0026lt;math.h\u0026gt; #define degree 1e-2 float fun_sin(float x) { float res, term; int i; int factor; // 阶乘 term = x; // 每一项的结果 factor = 1; res = term; for (i = 1; fabs(term) \u0026gt; degree; i++) { factor *= (2 * i) * (2 * i + 1); term = pow(-1, i) * pow(x, 2 * i + 1) / factor; res += term; } return res; } 上面的代码基本是严格按照公式计算的，可惜的是它并不能正常工作，这涉及到计算阶乘时整数溢出的问题。当输入比较小，比如0.","title":"C语言使用泰勒展开实现sinx并优化"},{"content":"","permalink":"https://againwq.github.io/tags/","summary":"","title":"标签"},{"content":"","permalink":"https://againwq.github.io/about/","summary":"","title":"关于"}]